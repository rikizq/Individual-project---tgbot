```python
import asyncio
import random
import requests

from aiogram import Bot, Dispatcher
from aiogram.filters import Command
from aiogram.types import Message

# --- –ù–ê–°–¢–†–û–ô–ö–ò ---
TOKEN = "8205786674:AAF0JYnQBU7F6-hXQ0eqjYoJZyxAFhlxKsA"
SEARCH_LIMIT = 5

bot = Bot(token=TOKEN)
dp = Dispatcher()

# --- –§—É–Ω–∫—Ü–∏–∏ –ø–æ–∏—Å–∫–∞ ---
def search_music(query, limit=SEARCH_LIMIT):
    url = "https://itunes.apple.com/search"
    params = {
        "term": query,
        "entity": "song",
        "limit": limit,
        "country": "RU",
        "lang": "ru_ru"
    }
    return requests.get(url, params=params).json().get("results", [])


def search_by_artist(artist, limit=SEARCH_LIMIT):
    return search_music(artist, limit)


def search_by_track(track, limit=SEARCH_LIMIT):
    return search_music(track, limit)


def get_top_tracks(limit=SEARCH_LIMIT):
    url = f"https://itunes.apple.com/ru/rss/topsongs/limit={limit}/json"
    try:
        data = requests.get(url).json()
        entries = data["feed"]["entry"]
        tracks = []
        for e in entries:
            tracks.append({
                "trackName": e["im:name"]["label"],
                "artistName": e["im:artist"]["label"],
                "previewUrl": e["link"][0]["attributes"]["href"]
            })
        return tracks
    except Exception:
        return []


def get_random_tracks(limit=SEARCH_LIMIT):
    terms = ["love", "pop", "rock", "a", "–∏", "me"]
    results = search_music(random.choice(terms), limit=20)
    return random.sample(results, min(limit, len(results)))


# --- –û—Ç–ø—Ä–∞–≤–∫–∞ ---
async def send_preview(message: Message, track):
    if "previewUrl" not in track:
        return

    await message.answer_audio(
        audio=track["previewUrl"],
        title=track.get("trackName"),
        performer=track.get("artistName"),
        caption="–í–æ—Ç —Ç–≤–æ–π —Ç—Ä–µ–∫!"
    )


# --- –ö–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞ ---
@dp.message(Command("start"))
async def start(message: Message):
    await message.answer(
        "üéµ –ü—Ä–∏–≤–µ—Ç!\n\n"
        "–ù–∞–ø–∏—à–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞ –∏–ª–∏ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è. –ò —è —Ç–µ–±–µ –µ–≥–æ –ø—Ä–∏—à–ª—é\n\n"
        "–ö–æ–º–∞–Ω–¥—ã:\n"
        "/track \n"
        "/artist \n"
        "/random\n"
        "/top\n"
        "/help"
    )


@dp.message(Command("help"))
async def help_cmd(message: Message):
    await message.answer(
        "‚ÑπÔ∏è –ö–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞:\n\n"
        "/track <–Ω–∞–∑–≤–∞–Ω–∏–µ> ‚Äî –ø–æ–∏—Å–∫ —Ç—Ä–µ–∫–∞\n"
        "/artist <–∏–º—è> ‚Äî —Ç—Ä–µ–∫–∏ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è\n"
        "/random ‚Äî —Å–ª—É—á–∞–π–Ω—ã–µ —Ç—Ä–µ–∫–∏\n"
        "/top ‚Äî —Ç–æ–ø –ø–µ—Å–µ–Ω\n\n"
        "–ú–æ–∂–Ω–æ –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—Å–∞—Ç—å –∑–∞–ø—Ä–æ—Å —Ç–µ–∫—Å—Ç–æ–º."
    )

# --- –ü–æ–∏—Å–∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç—Ä–µ–∫–∞ ---

@dp.message(Command("track"))
async def track_cmd(message: Message):
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        await message.answer("–£–∫–∞–∂–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞ –ø–æ—Å–ª–µ /track")
        return

    tracks = search_by_track(args[1])
    if not tracks:
        await message.answer("–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
        return

    for t in tracks:
        await send_preview(message, t)

# --- –ü–æ–∏—Å–∫ –ø–æ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—é ---

@dp.message(Command("artist"))
async def artist_cmd(message: Message):
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        await message.answer("–£–∫–∞–∂–∏ –∏–º—è –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è –ø–æ—Å–ª–µ /artist")
        return

    tracks = search_by_artist(args[1])
    if not tracks:
        await message.answer("–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return

    for t in tracks:
        await send_preview(message, t)

# --- –†–∞–Ω–¥–æ–º–Ω—ã–π —Ç—Ä–µ–∫ ---

@dp.message(Command("random"))
async def random_cmd(message: Message):
    tracks = get_random_tracks()
    if not tracks:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ç—Ä–µ–∫–∏")
        return

    for t in tracks:
        await send_preview(message, t)

# --- –ü–æ–∏—Å–∫ –ø–æ —Ç–æ–ø—É ---

@dp.message(Command("top"))
async def top_cmd(message: Message):
    tracks = get_top_tracks(limit=5)
    if not tracks:
        await message.answer("–¢–æ–ø –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
        return

    for t in tracks:
        await send_preview(message, t)


# --- –õ—é–±–æ–π —Ç–µ–∫—Å—Ç (–ø–æ–∏—Å–∫ –ø–æ –æ–±—â–µ–º—É –∑–∞–ø—Ä–æ—Å—É) ---
@dp.message()
async def text_search(message: Message):
    query = message.text.strip()
    if not query:
        return

    tracks = search_music(query)
    if not tracks:
        await message.answer("–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
        return

    for t in tracks:
        await send_preview(message, t)


# --- –ó–∞–ø—É—Å–∫ ---
async def main():
    print("üéµ –ú—É–∑—ã–∫–∞–ª—å–Ω—ã–π –±–æ—Ç –∑–∞–ø—É—â–µ–Ω")
    await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(main())
```

